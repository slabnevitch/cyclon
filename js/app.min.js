/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/**-----------------------

 docSlider.js - ver.3.0.1
 URL : https://prjct-samwest.github.io/docSlider/
 created by SamWest
 Copyright (c) 2020 SamWest.
 This plugin is released under the MIT License.

 -----------------------**/

const docSlider = (function () {

    let undefined;
    let sc, pcr;
    let d = {};

    const op = {
        speed        : 600,
        easing       : 'ease',
        pager        : true,
        horizontal   : false,
        startSpeed   : null,
        scrollReset  : false,
        complete     : function () {},
        beforeChange : function () {},
        afterChange  : function () {},
        setInitCss : function(index, horizontal){

            const point = horizontal ? 'left' : 'top';
            const style = {};

            style[point] = index * 100 + '%';

            return style;

        },
        setChangeCss   : function (index, currentIndex, speed, easing, horizontal) {

            const xy = horizontal ? 'X' : 'Y';
            const style = {};

            style.transitionProperty = 'transform';
            style.transitionDuration = speed + 'ms';
            style.transitionTimingFunction = easing;
            style.transform = 'translate' + xy + '(-' + currentIndex * 100 + '%)';

            return style;

        }
    };

    const f = {

        setOptions : function (options) {

            if(options === undefined)
                return;

            const keys = Object.keys(options);

            for(let i = 0; i < keys.length; i++){

                const key = keys[i];

                op[key] = options[key];

            }

            if(!op.pager)
                u.updatePager = function () {};

        },

        createInner : function(){

            const wrapper = document.querySelector('.docSlider');
            const inner   = document.createElement('div');
            const pages   = document.querySelectorAll('.docSlider > *:not(.docSlider-pager)');

            inner.classList.add('docSlider-inner');

            for(let i = 0; i < pages.length; i++){

                const page = pages[i];
                const prop = op.setInitCss(i,op.horizontal);

                for(let p = 0; p < Object.keys(prop).length; p++){

                    const key = Object.keys(prop)[p];

                    page.style[key] = prop[key];

                }

                page.classList.add('docSlider-page');
                page.classList.add('docSlider-scroll');
                page.setAttribute('data-ds-index',i.toString());
                page.setAttribute('tabindex','0');

                inner.appendChild(page);

            }

            wrapper.appendChild(inner);

        },

        createPager : function () {

            if(!op.pager)
                return;

            const pageLength = document.querySelectorAll('.docSlider-inner > *').length;

            if(document.querySelector('.docSlider-pager')){

                const buttons = document.querySelectorAll('.docSlider-button');

                for(let i = 0; i < buttons.length; i++){

                    let button = buttons[i];

                    button.setAttribute('data-ds-jump',i.toString());
                    button.setAttribute('tabindex','-1');

                }

            }else{
                const pager      = document.createElement('nav');

                pager.classList.add('docSlider-pager');

                for(let i = 0; i < pageLength; i++){

                    let button = document.createElement('button');

                    button.classList.add('docSlider-button');
                    button.setAttribute('data-ds-jump',i.toString());
                    button.setAttribute('tabindex','-1');

                    pager.appendChild(button);

                }

                document.querySelector('.docSlider').appendChild(pager);

            }

        },

        setData : function () {

            d.html    = document.documentElement;
            d.wrapper = document.querySelector('.docSlider');
            d.pages   = document.querySelectorAll('.docSlider-inner > *');
            d.pager   = document.querySelector('.docSlider-pager');
            d.buttons = document.querySelectorAll('.docSlider-pager .docSlider-button');
            d.length  = d.pages.length;
            d.now     = 0;
            d.past    = 0;
            d.xy      = op.horizontal ? 'X' : 'Y';
            d.yx      = !op.horizontal ? 'X' : 'Y';
            d.wheel   = 'onwheel' in document ? 'wheel' : 'onmousewheel' in document ? 'mousewheel' : 'DOMMouseScroll';
            d.wheelTick   = true;
            d.wheelEnable = true;
            d.fromPoint   = 'elementsFromPoint' in document ? 'elementsFromPoint' : 'msElementsFromPoint';
            d.isTouch     = 'ontouchstart' in window;
            d.isMobile    = /iPhone|Android.+Mobile/.test(navigator.userAgent);
            d.resizeTimer = 0;
            d.speed       = null;
            d.easing      = null;
            d.enable      = true;
            d.type        = null;
            d.pastType    = null;
            d.active      = null;

            u.updatePager();
            u.updateClass();

            d.active = d.pages[d.now];
            d.pages[d.now].focus({preventScroll :false});

        },

        setEvent : function () {

            for(let i = 0; i < d.length; i++){

                const page   = d.pages[i];
                const button = d.buttons[i];

                page.addEventListener('focusin',u.focusin);

                if(button === undefined)
                    continue;

                button.addEventListener('click',u.pagerClick);

            }

            document.addEventListener('keyup',u.keyup);
            document.addEventListener(d.wheel,u.wheel);
            d.pages[0].addEventListener('transitionstart',u.transitionstart);
            d.pages[0].addEventListener('transitionend',u.transitionend);

            if(d.isTouch){

                d.touch = {
                    move  : false,
                    nextX : 'right',
                    prevX : 'left',
                    nextY : 'bottom',
                    prevY : 'top',
                    X : {},
                    Y : {}
                }

                d.wrapper.addEventListener('touchstart',u.touchstart,false);
                d.wrapper.addEventListener('touchmove',u.touchmove,false);
                d.wrapper.addEventListener('touchend',u.touchend,false);

            }

            if(d.isMobile){

                u.setFV();
                window.addEventListener('resize',u.resize);

            }

        },

        hashJump : function () {

            const to = u.hashToIndex(location.hash);

            if(to === d.now)
                return false;

            d.speed = op.startSpeed === null ? op.speed : op.startSpeed;
            d.type = 'anchor';

            if(d.speed){

                setTimeout(function () {

                    u.pageChange(to);

                },200)

            }else{

                u.pageChange(to);

            }

            return true;

        }

    };

    const u = {

        hashToIndex : function (hash) {

            return (function () {

                if(hash.length){

                    let page = document.querySelector(hash);

                    if(!page || !page.hasAttribute('data-ds-index'))
                        return 0;

                    return Number(page.getAttribute('data-ds-index'));

                }else{

                    return 0;

                }

            })();

        },

        indexCheck : function(num){

            return (num >= 0 && num < d.length) ? num : d.now;

        },

        pageChange : function(to){

            if(d.type !== 'focus')
                d.pages[to].focus();

            d.active = d.pages[to];

            if(to === d.now)
                return;

            d.type = d.type ? d.type : 'focus';
            d.past = d.now;
            d.now  = to;

            let speed  = d.speed  === null ? op.speed  : d.speed;

            const easing = d.easing === null ? op.easing : d.easing;

            for(let i = 0; i < d.length; i++){

                const page = d.pages[i];
                const prop = op.setChangeCss(i, d.now, speed, easing, op.horizontal);

                for(let p = 0; p < Object.keys(prop).length; p++){

                    const key = Object.keys(prop)[p];

                    page.style[key] = prop[key];

                }

            }

            if(!speed){

                if(op.scrollReset)
                    u.scrollReset(d.pages[d.now]);

                if(pcr)
                    u.animationReset(d.past);

                op.beforeChange(d.past, d.pages[d.past], d.now, d.pages[d.now], d.type);
                d.pastType = d.type;
                d.type = null;

                if(sc)
                    scrollCue._updateWithDocSlider();

                op.afterChange(d.now, d.pages[d.now], d.past, d.pages[d.past], d.pastType);
                d.pastType = null;

            }

            d.speed  = null;
            d.easing = null;

            u.updatePager();
            u.updateClass();

        },

        focusin : function(){

            const to = Number(this.getAttribute('data-ds-index'));

            d.type = d.type ? d.type : 'focus';

            u.pageChange(to);

        },

        focusinx : function(){

            const to = Number(this.getAttribute('data-ds-index'));

            d.active = d.pages[to];

            if(to === d.now)
                return;

            d.type = d.type ? d.type : 'focus';
            d.past = d.now;
            d.now  = to;

            let speed  = d.speed  === null ? op.speed  : d.speed;

            const easing = d.easing === null ? op.easing : d.easing;

            for(let i = 0; i < d.length; i++){

                const page = d.pages[i];
                const prop = op.setChangeCss(i, d.now, speed, easing, op.horizontal);

                for(let p = 0; p < Object.keys(prop).length; p++){

                    const key = Object.keys(prop)[p];

                    page.style[key] = prop[key];

                }

            }

            if(!speed){

                if(op.scrollReset)
                    u.scrollReset(d.pages[d.now]);

                if(pcr)
                    u.animationReset(d.past);

                op.beforeChange(d.past, d.pages[d.past], d.now, d.pages[d.now], d.type);
                d.pastType = d.type;
                d.type = null;

                if(sc)
                    scrollCue._updateWithDocSlider();

                op.afterChange(d.now, d.pages[d.now], d.past, d.pages[d.past], d.pastType);
                d.pastType = null;

            }

            d.speed  = null;
            d.easing = null;

            u.updatePager();
            u.updateClass();

        },

        pagerClick : function(){

            if(!d.enable)
                return;

            const to = Number(this.getAttribute('data-ds-jump'));

            d.type = 'pager';
            u.pageChange(to);

        },

        updatePager : function () {

            for(let i = 0; i < d.length; i++ ){

                const button = d.buttons[i];

                if(button === undefined)
                    continue;

                button.classList.remove('selected');

            }

            if(d.buttons[d.now] === undefined)
                return ;

            d.buttons[d.now].classList.add('selected');

        },

        updateClass : function(){

            const past      = d.pages[d.past];
            const pastIndex = past.getAttribute('data-ds-index');
            const pastPage  = Number(pastIndex) +1;
            const pastId    = past.hasAttribute('id') ? past.getAttribute('id') : false;

            const now = d.pages[d.now];
            const nowIndex = now.getAttribute('data-ds-index');
            const nowPage  = Number(nowIndex) +1;
            const nowId    = now.hasAttribute('id') ? now.getAttribute('id') : false;

            d.html.classList.remove('docSlider-index_' + pastIndex);
            d.html.classList.remove('docSlider-page_'  + pastPage);
            d.html.classList.remove('docSlider-id_'    + pastId);

            d.html.classList.add('docSlider-index_' + nowIndex);
            d.html.classList.add('docSlider-page_'  + nowPage);
            if(nowId) d.html.classList.add('docSlider-id_'    + nowId);

            d.pages[d.past].classList.remove('docSlider-current');
            d.pages[d.now].classList.add('docSlider-current');

        },

        keyup : function(e){

            if(!d.enable)
                return;

            if(d.pages[d.now] !== document.activeElement)
                return;

            let to;
            const key   = e.key;
            const shift = e.shiftKey;
            const page  = d.pages[d.now];

            if((shift && / |Spacebar/.test(key) || !shift && /ArrowUp|Up|PageUp/.test(key)) && u.scrollEnd(page,'top')){

                to = d.now - 1;

            }else if(!shift && / |Spacebar|ArrowDown|Down|PageDown/.test(key) && u.scrollEnd(page,'bottom')) {

                to = d.now + 1;

            }else if(!shift && key === 'Home'){

                to = 0;

            }else if(!shift && key === 'End'){

                to = d.length - 1;

            }else if(!shift && op.horizontal && /ArrowLeft|Left/.test(key)){

                to = d.now - 1;

            }else if(!shift && op.horizontal && /ArrowRight|Right/.test(key)){

                to = d.now + 1;

            }else{

                return;

            }

            if(u.indexCheck(to) === d.now)
                return;

            d.type = 'key';
            u.pageChange(to);

        },

        scrollEnd : function (element,direction) {

            switch (direction) {
                case 'top'    : return element.scrollTop  <= 0;
                case 'bottom' : return element.scrollTop  >= element.scrollHeight - element.clientHeight;
                case 'left'   : return element.scrollLeft <= 0;
                case 'right'  : return element.scrollLeft >= element.scrollWidth - element.clientWidth;
                default       : return direction;
            }

        },

        wheel : function (e) {

            if(!d.wheelTick)
                return;

            requestAnimationFrame(function () {

                d.wheelTick = true;

                if(!d.enable)
                    return;

                if(!d.wheelEnable)
                    return;

                const delta    = e.deltaY ? -(e.deltaY) : e.wheelDelta ? e.wheelDelta : -(e.detail);
                const elms     = document[d.fromPoint](e.pageX,e.pageY);
                const distance = delta > 0 ? 'top' : 'bottom';
                const to       = u.indexCheck(distance === 'top' ? d.now - 1 : d.now + 1);

                if(d.active !== d.pages[d.now])
                    return;

                if(to === d.now)
                    return;

                for(let i = 0; i < elms.length; i ++){

                    const elm = elms[i];

                    if(elm.classList.contains('docSlider-scroll') && !u.scrollEnd(elm,distance))
                        return

                }

                d.type = 'scroll';
                u.pageChange(to);

            });

            d.wheelTick = false;

        },

        transitionstart : function () {

            d.wheelEnable = false;

            if(op.scrollReset)
                u.scrollReset(d.pages[d.now]);

            if(pcr)
                u.animationReset(d.past);

            op.beforeChange(d.past, d.pages[d.past], d.now, d.pages[d.now], d.type);
            d.pastType = d.type;
            d.type = null;

        },

        transitionend : function () {

            d.wheelEnable = true;

            if(sc)
                scrollCue._updateWithDocSlider();

            op.afterChange(d.now, d.pages[d.now], d.past, d.pages[d.past], d.pastType);
            d.pastType = null;

        },

        resize : function(){

            if(d.resizeTimer > 0)
                clearTimeout(d.resizeTimer);

            d.resizeTimer = setTimeout(u.setFV,200);

        },

        setFV : function () {

            d.wrapper.style.height = window.innerHeight + '';
            d.wrapper.style.height = window.innerHeight + 'px';

        },

        touchstart : function (e) {

            if(!d.enable)
                return;

            if(e.touches.length > 1)
                return;

            d.touch.move = false;
            d.touch.X.start = e.touches[0].pageX;
            d.touch.Y.start = e.touches[0].pageY;

        },

        touchmove : function (e) {

            if(!d.enable)
                return;

            if(e.touches.length > 1){
                e.preventDefault();
                return;
            }

            d.touch.move = true;
            d.touch.X.move = e.changedTouches[0].pageX;
            d.touch.Y.move = e.changedTouches[0].pageY;

        },

        touchend : function (e) {

            if(!d.enable)
                return;


            if(e.touches.length > 1)
                return;

            if(!d.touch.move)
                return;

            d.touch.X.distance = d.touch.X.move - d.touch.X.start;
            d.touch.Y.distance = d.touch.Y.move - d.touch.Y.start;

            if(Math.abs(d.touch[d.xy].distance) < Math.abs(d.touch[d.yx].distance))
                return;

            const np = d.touch[d.xy].distance < 0 ? 'next' : 'prev';
            const to = u.indexCheck(np === 'next' ? d.now + 1 : d.now - 1);

            if(to === d.now)
                return;

            if((d.now === 0 && np === 'prev') || (d.now === d.length-1 && np === 'next'))
                return;

            const direction = d.touch[np + d.xy];
            const elms      = document[d.fromPoint](d.touch.X.start,d.touch.Y.start);

            for(let i = 0; i < elms.length; i++){

                const elm = elms[i];

                if(elm.classList.contains('docSlider-scroll') && !u.scrollEnd(elm,direction))
                    return;

            }

            d.type = 'scroll';
            u.pageChange(to);

        },

        scrollReset : function (page){

            page.scrollTop = 0;
            page.scrollLeft = 0;

        },

        animationReset : function (index){

            let selector = '[data-scpage][data-show="true"]'
            let elms = document.querySelectorAll(selector);

            if(!elms.length)
                return false;

            for(let i=0; i < elms.length; i++){

                let elm = elms[i];
                let classes = elm.getAttribute('data-addClass');

                if(elm.getAttribute('data-scpage') === index+'')
                    continue;

                elm.removeAttribute('style');
                elm.removeAttribute('data-show');

                if(!classes)
                    continue;

                classes = classes.split(' ');

                for(let j=0; j<classes.length; j++){

                    let className = classes[j];

                    elm.classList.remove(className);

                }

            }

            scrollCue._searchElements();

        },

    };

    return {

        init : function (options) {

            let startHash;

            f.setOptions(options);
            f.createInner();
            f.createPager();
            f.setData();
            f.setEvent();
            startHash = f.hashJump();

            sc = typeof scrollCue === 'undefined' ? false : scrollCue._hasDocSlider();
            pcr = typeof scrollCue === 'undefined' ? false : scrollCue._hasPageChangeReset();

            if(sc){

                scrollCue._initWithDocSlider(startHash);

            }

            op.complete(op, docSlider.getElements());

        },

        jumpPage : function (to, speed, easing) {

            let index;

            if(to === undefined)
                return;

            if(isNaN(to)){

                index = u.hashToIndex('#'+to.replace('#',''));

            }else{

                index = u.indexCheck(to < 0 ? d.length + to : to);

            }

            d.speed  = speed  === undefined ? null : speed;
            d.easing = easing === undefined ? null : easing;
            d.type   = 'jumpPage';

            u.pageChange(index);

        },

        nextPage : function (speed, easing) {

            const index = u.indexCheck(d.now +1);

            d.speed  = speed  === undefined ? null : speed;
            d.easing = easing === undefined ? null : easing;
            d.type   = 'nextPage';

            u.pageChange(index);

        },

        prevPage : function (speed, easing) {

            const index = u.indexCheck(d.now -1);

            d.speed  = speed  === undefined ? null : speed;
            d.easing = easing === undefined ? null : easing;
            d.type   = 'prevPage';

            u.pageChange(index);

        },

        getOptions : function () {

            return op;

        },

        getElements : function () {

            return {
                wrapper : d.wrapper,
                pages   : d.pages,
                pager   : d.pager,
                buttons : d.buttons,
            };

        },

        getCurrentIndex : function () {

            return d.now;

        },

        getCurrentPage : function () {

            return d.pages[d.now];

        },

        enable : function (toggle) {

            d.enable = toggle === undefined ? !d.enable : toggle;

            const tabindex = d.enable ? '0' : '-1';

            for(let i = 0; i < d.length; i++){

                d.pages[i].setAttribute('tabindex',tabindex);

            }

        },
        _getWheelEnable : function (){

            return d.wheelEnable;

        }

    }


})();
exports.docSlider = docSlider;

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_docslider_docSlider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _node_modules_docslider_docSlider_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_docslider_docSlider_js__WEBPACK_IMPORTED_MODULE_0__);
// // Import jQuery module (npm i jquery)
// import $ from 'jquery'
// window.jQuery = $
// window.$ = $

// // Import vendor jQuery plugin example (not module)
// import Parallax from 'parallax-js'

console.log(_node_modules_docslider_docSlider_js__WEBPACK_IMPORTED_MODULE_0__["docSlider"]);

// import Swiper, { Navigation, Mousewheel } from 'swiper';
// Swiper.use([Navigation, Mousewheel]);

// import FormHandler from 'formhandler.js';

//- SERVIVE FUNCTIONS==================

//- remove-class--------------------------
//- require('./vendor/libs-vanilla/service-functions/remove-class.js')

//- siblings--------------------------
//- require('./vendor/libs-vanilla/service-functions/siblings.js')

//- webp-detection--------------------------
// require('./vendor/libs-vanilla/service-functions/webp-detection.js')

//- dropdown-toggle on touch devices--------------------------
//- require('./vendor/libs-vanilla/service-functions/dropdown-toggle.js')

//- isMobile--------------------------
// require('./vendor/libs-vanilla/service-functions/mobileDetect.js')

//- All in one file--------------------------
// require('./vendor/libs-vanilla/service-functions/all-functions.js')

//- WITH JQUERY===================================
//- jquery--------------------------
// require('./vendor/libs/jquery/jquery-3.1.1.min.js')

//- jquery-UI--------------------------Не проверено!
// require('./vendor/libs/jquery-ui/jquery-ui.min.js')

//- dl-menu--------------------------
// require('./vendor/libs/dlmenu/js/modernizr.custom.js')
// var dlmenu = require('./vendor/libs/dlmenu/js/jquery.dlmenu.js')
// папку dl-menu/fonts копировать в главную fonts и переименовать в "dl-menu-font"

//- magnific-popup--------------------------
// require('./vendor/libs/magnific-popup/dist/jquery.magnific-popup.min.js')

//- slick--------------------------
// require('./vendor/libs/slick/slick.min.js')

//- slick-master (без лишних контейнеров)--------------------------
// require('./vendor/libs/slick-master/slick.js')

//- superfish--------------------------Не проверено!
// require('./vendor/libs/superfish/dist/js/hoverIntent.js')
// require('./vendor/libs/superfish/dist/js/superfish.min.js')

//- end WITH JQUERY===================================

//- VANILLA JS===================================
//- dynamic-adaptive--------------------------
// require('./vendor/libs-vanilla/dynamic-adaptive/da(es6).js')

//- slideout--------------------------
// var Slideout = require('./vendor/libs-vanilla/slideout/slideout.js')

//- multilevel-panel--------------------------Не проверено!
// require('./vendor/libs-vanilla/multilevel-panel/multilevel-panel.js')

//- multilevel-dropdown-menu--------------------------
// require('./vendor/libs-vanilla/multilevel-dropdown/multidropdown.js')

//- lazysizes--------------------------Не проверено!
// require('./vendor/libs-vanilla/lazysizes/lazysizes.min.js')

//- accordion--------------------------
// require('./vendor/libs-vanilla/accordion/vanilla-accordion.js')

//- tabs--------------------------
// require('./vendor/libs-vanilla/tabs/tabs-pure.js')

//- tabs-accordion-combine--------------------------
// require('./vendor/libs-vanilla/tabs-accordion-combine/tabs-accordion.js')

//- micromodal--------------------------
// var MicroModal = require('./vendor/libs-vanilla/micromodal/micromodal.js')

//- swiper--------------------------
// require('./vendor/libs-vanilla/swiper/swiper-bundle.min.js')

//- tiny-slider--------------------------Не проверено!
// require('./vendor/libs-vanilla/tiny-slider/dist/tiny-slider.js')

//- wNumb--------------------------
// var wNumb = require('./vendor/libs-vanilla/wnumb/wNumb.js')

// - noUiSlider--------------------------
// var noUiSlider = require('./vendor/libs-vanilla/noUiSlider/nouislider.min.js')

//- iMask--------------------------
// require('./vendor/libs-vanilla/imask/imask.js')

//- FormHandler--------------------------
//- html разыметка должна быть как в доке https://ivangrimes.github.io/formhandler.js/, обязателько должен присутствовать <div class="formhandler__notices"></div>!
//- кастомные стили для инпута и ошибок здесь _misc/formHandler-custom
// var FormHandler = require('./vendor/libs-vanilla/formhandler.js-1.1.2/dist/js/FormHandler.js')

//- ratings--------------------------
// require('./vendor/libs-vanilla/rating/ratings.js')

//- scroll-to-sects--------------------------
// require('./vendor/libs-vanilla/scroll-to-sects/scrolltosect.js')

//- tippy--------------------------
//- https://atomiks.github.io/tippyjs/
//- base using:  html: <button data-tippy-content="Tooltip">Text</button>; js: tippy('[data-tippy-content]');
// import tippy from 'tippy.js';

//- sticky-sidebar -------------------------- Не проверено!
//- https://abouolia.github.io/sticky-sidebar/#usage
// require('./vendor/libs-vanilla/sticky-sidebar/dist/resizeSensor.js')
// require('./vendor/libs-vanilla/sticky-sidebar/dist/sticky-sidebar.min.js')

//- simplebar--------------------------
//- USE:	new SimpleBar(document.querySelector('mySelector'), { autoHide: false });
// var SimpleBar = require('./vendor/libs-vanilla/simplebar/simplebar.min.js')

//- fstdropdown (кастомный селект), исп-е.: <select data-searchdisable="true" class="fstdropdown-select">
// require('./vendor/libs-vanilla/fstdropdown/fstdropdown.min.js')

//- baguetteBox-------------------------- use: https://github.com/feimosi/baguetteBox.js#usage
// var baguetteBox = require('./vendor/libs-vanilla/baguetteBox/dist/baguetteBox.min.js')

//- counter--------------------------
// require('./vendor/libs-vanilla/counter/counter.js')

// var tingle = require('./vendor/libs-vanilla/tingle-master/dist/tingle.js')
// var docSlider = require('./vendor/libs-vanilla/docSlider/docSlider.js')

//- end VANILLA JS===================================

// require('./vendor/color-scheme-switcher.js')
// require('./vendor/jquery-scrollify/jquery.scrollify.js')
__webpack_require__(2);
__webpack_require__(3);
document.addEventListener('DOMContentLoaded', function () {
  var inview = new Waypoint.Inview({
    element: document.querySelector('.page-03'),
    enter: function enter(direction) {
      console.log('Enter triggered with direction ' + direction);
    },
    entered: function entered(direction) {
      console.log('Entered triggered with direction ' + direction);
    },
    exit: function exit(direction) {
      console.log('Exit triggered with direction ' + direction);
    },
    exited: function exited(direction) {
      console.log('Exited triggered with direction ' + direction);
    }
  });
  var observer = new IntersectionObserver(function (entries, observer) {
    entries.forEach(function (entry) {
      console.log('goal!!');
      // var targetElement = entry.target,
      // 	skotnik = 
    });
  });

  observer.observe(document.querySelector('.page-12'));
}); //DOMContentLoaded
// Для правильного импорта нужно добавить " exports.docSlider = docSlider;" в node_modules/docslider/docSlider.js
_node_modules_docslider_docSlider_js__WEBPACK_IMPORTED_MODULE_0__["docSlider"].init({
  scrollReset: true,
  beforeChange: function beforeChange(index) {
    // console.log( 'beforeChange' );
    // toPage.classList.add('docSlider-next'); 
    // document.querySelectorAll('.page')[index+1].classList.add('docSlider-next');
    // document.querySelectorAll('.page')[index-1].classList.add('docSlider-prev');
  },
  afterChange: function afterChange(toIndex) {
    console.log(toIndex);
    var currentPage = document.querySelectorAll('.page')[toIndex];
    // document.querySelectorAll('.page')[index].classList.remove('docSlider-next');
    // console.log(currentPage)
    // console.log(currentPage.querySelectorAll('[data-animated-counter]'))
    if (currentPage.querySelectorAll('[data-animated-counter]')) {
      digitsCountersInit(currentPage.querySelectorAll('[data-animated-counter]'));
    }
  }
});
window.addEventListener('load', winLoad);
function digitsCountersInit(digitsCountersItems) {
  var digitsCounters = digitsCountersItems ? digitsCountersItems : document.querySelectorAll('[data-animated-counter]');
  if (digitsCounters) {
    digitsCounters.forEach(function (digitsCounter) {
      digitsCountersAnimate(digitsCounter);
    });
  }
}
function digitsCountersAnimate(digitsCounter) {
  var startTimestamp = null,
    duration = parseInt(digitsCounter.dataset.animatedCounter) ? parseInt(digitsCounter.dataset.animatedCounter) : 2000,
    startValue = parseInt(digitsCounter.innerHTML),
    startPosition = 0,
    step = function step(timestamp) {
      if (!startTimestamp) {
        startTimestamp = timestamp;
      }
      var progress = Math.min((timestamp - startTimestamp) / duration, 1);
      digitsCounter.innerHTML = Math.floor(progress * (startPosition + startValue));
      if (progress < 1) {
        window.requestAnimationFrame(step);
      }
    };
  window.requestAnimationFrame(step);
}
function winLoad() {

  // digitsCountersInit();
}

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
/*!
Waypoints - 4.0.1
Copyright © 2011-2016 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/
(function () {
  'use strict';

  var keyCounter = 0;
  var allWaypoints = {};

  /* http://imakewebthings.com/waypoints/api/waypoint */
  function Waypoint(options) {
    if (!options) {
      throw new Error('No options passed to Waypoint constructor');
    }
    if (!options.element) {
      throw new Error('No element option passed to Waypoint constructor');
    }
    if (!options.handler) {
      throw new Error('No handler option passed to Waypoint constructor');
    }
    this.key = 'waypoint-' + keyCounter;
    this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options);
    this.element = this.options.element;
    this.adapter = new Waypoint.Adapter(this.element);
    this.callback = options.handler;
    this.axis = this.options.horizontal ? 'horizontal' : 'vertical';
    this.enabled = this.options.enabled;
    this.triggerPoint = null;
    this.group = Waypoint.Group.findOrCreate({
      name: this.options.group,
      axis: this.axis
    });
    this.context = Waypoint.Context.findOrCreateByElement(this.options.context);
    if (Waypoint.offsetAliases[this.options.offset]) {
      this.options.offset = Waypoint.offsetAliases[this.options.offset];
    }
    this.group.add(this);
    this.context.add(this);
    allWaypoints[this.key] = this;
    keyCounter += 1;
  }

  /* Private */
  Waypoint.prototype.queueTrigger = function (direction) {
    this.group.queueTrigger(this, direction);
  };

  /* Private */
  Waypoint.prototype.trigger = function (args) {
    if (!this.enabled) {
      return;
    }
    if (this.callback) {
      this.callback.apply(this, args);
    }
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/destroy */
  Waypoint.prototype.destroy = function () {
    this.context.remove(this);
    this.group.remove(this);
    delete allWaypoints[this.key];
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/disable */
  Waypoint.prototype.disable = function () {
    this.enabled = false;
    return this;
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/enable */
  Waypoint.prototype.enable = function () {
    this.context.refresh();
    this.enabled = true;
    return this;
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/next */
  Waypoint.prototype.next = function () {
    return this.group.next(this);
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/previous */
  Waypoint.prototype.previous = function () {
    return this.group.previous(this);
  };

  /* Private */
  Waypoint.invokeAll = function (method) {
    var allWaypointsArray = [];
    for (var waypointKey in allWaypoints) {
      allWaypointsArray.push(allWaypoints[waypointKey]);
    }
    for (var i = 0, end = allWaypointsArray.length; i < end; i++) {
      allWaypointsArray[i][method]();
    }
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/destroy-all */
  Waypoint.destroyAll = function () {
    Waypoint.invokeAll('destroy');
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/disable-all */
  Waypoint.disableAll = function () {
    Waypoint.invokeAll('disable');
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/enable-all */
  Waypoint.enableAll = function () {
    Waypoint.Context.refreshAll();
    for (var waypointKey in allWaypoints) {
      allWaypoints[waypointKey].enabled = true;
    }
    return this;
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/refresh-all */
  Waypoint.refreshAll = function () {
    Waypoint.Context.refreshAll();
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/viewport-height */
  Waypoint.viewportHeight = function () {
    return window.innerHeight || document.documentElement.clientHeight;
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/viewport-width */
  Waypoint.viewportWidth = function () {
    return document.documentElement.clientWidth;
  };
  Waypoint.adapters = [];
  Waypoint.defaults = {
    context: window,
    continuous: true,
    enabled: true,
    group: 'default',
    horizontal: false,
    offset: 0
  };
  Waypoint.offsetAliases = {
    'bottom-in-view': function bottomInView() {
      return this.context.innerHeight() - this.adapter.outerHeight();
    },
    'right-in-view': function rightInView() {
      return this.context.innerWidth() - this.adapter.outerWidth();
    }
  };
  window.Waypoint = Waypoint;
})();
(function () {
  'use strict';

  function requestAnimationFrameShim(callback) {
    window.setTimeout(callback, 1000 / 60);
  }
  var keyCounter = 0;
  var contexts = {};
  var Waypoint = window.Waypoint;
  var oldWindowLoad = window.onload;

  /* http://imakewebthings.com/waypoints/api/context */
  function Context(element) {
    this.element = element;
    this.Adapter = Waypoint.Adapter;
    this.adapter = new this.Adapter(element);
    this.key = 'waypoint-context-' + keyCounter;
    this.didScroll = false;
    this.didResize = false;
    this.oldScroll = {
      x: this.adapter.scrollLeft(),
      y: this.adapter.scrollTop()
    };
    this.waypoints = {
      vertical: {},
      horizontal: {}
    };
    element.waypointContextKey = this.key;
    contexts[element.waypointContextKey] = this;
    keyCounter += 1;
    if (!Waypoint.windowContext) {
      Waypoint.windowContext = true;
      Waypoint.windowContext = new Context(window);
    }
    this.createThrottledScrollHandler();
    this.createThrottledResizeHandler();
  }

  /* Private */
  Context.prototype.add = function (waypoint) {
    var axis = waypoint.options.horizontal ? 'horizontal' : 'vertical';
    this.waypoints[axis][waypoint.key] = waypoint;
    this.refresh();
  };

  /* Private */
  Context.prototype.checkEmpty = function () {
    var horizontalEmpty = this.Adapter.isEmptyObject(this.waypoints.horizontal);
    var verticalEmpty = this.Adapter.isEmptyObject(this.waypoints.vertical);
    var isWindow = this.element == this.element.window;
    if (horizontalEmpty && verticalEmpty && !isWindow) {
      this.adapter.off('.waypoints');
      delete contexts[this.key];
    }
  };

  /* Private */
  Context.prototype.createThrottledResizeHandler = function () {
    var self = this;
    function resizeHandler() {
      self.handleResize();
      self.didResize = false;
    }
    this.adapter.on('resize.waypoints', function () {
      if (!self.didResize) {
        self.didResize = true;
        Waypoint.requestAnimationFrame(resizeHandler);
      }
    });
  };

  /* Private */
  Context.prototype.createThrottledScrollHandler = function () {
    var self = this;
    function scrollHandler() {
      self.handleScroll();
      self.didScroll = false;
    }
    this.adapter.on('scroll.waypoints', function () {
      if (!self.didScroll || Waypoint.isTouch) {
        self.didScroll = true;
        Waypoint.requestAnimationFrame(scrollHandler);
      }
    });
  };

  /* Private */
  Context.prototype.handleResize = function () {
    Waypoint.Context.refreshAll();
  };

  /* Private */
  Context.prototype.handleScroll = function () {
    var triggeredGroups = {};
    var axes = {
      horizontal: {
        newScroll: this.adapter.scrollLeft(),
        oldScroll: this.oldScroll.x,
        forward: 'right',
        backward: 'left'
      },
      vertical: {
        newScroll: this.adapter.scrollTop(),
        oldScroll: this.oldScroll.y,
        forward: 'down',
        backward: 'up'
      }
    };
    for (var axisKey in axes) {
      var axis = axes[axisKey];
      var isForward = axis.newScroll > axis.oldScroll;
      var direction = isForward ? axis.forward : axis.backward;
      for (var waypointKey in this.waypoints[axisKey]) {
        var waypoint = this.waypoints[axisKey][waypointKey];
        if (waypoint.triggerPoint === null) {
          continue;
        }
        var wasBeforeTriggerPoint = axis.oldScroll < waypoint.triggerPoint;
        var nowAfterTriggerPoint = axis.newScroll >= waypoint.triggerPoint;
        var crossedForward = wasBeforeTriggerPoint && nowAfterTriggerPoint;
        var crossedBackward = !wasBeforeTriggerPoint && !nowAfterTriggerPoint;
        if (crossedForward || crossedBackward) {
          waypoint.queueTrigger(direction);
          triggeredGroups[waypoint.group.id] = waypoint.group;
        }
      }
    }
    for (var groupKey in triggeredGroups) {
      triggeredGroups[groupKey].flushTriggers();
    }
    this.oldScroll = {
      x: axes.horizontal.newScroll,
      y: axes.vertical.newScroll
    };
  };

  /* Private */
  Context.prototype.innerHeight = function () {
    /*eslint-disable eqeqeq */
    if (this.element == this.element.window) {
      return Waypoint.viewportHeight();
    }
    /*eslint-enable eqeqeq */
    return this.adapter.innerHeight();
  };

  /* Private */
  Context.prototype.remove = function (waypoint) {
    delete this.waypoints[waypoint.axis][waypoint.key];
    this.checkEmpty();
  };

  /* Private */
  Context.prototype.innerWidth = function () {
    /*eslint-disable eqeqeq */
    if (this.element == this.element.window) {
      return Waypoint.viewportWidth();
    }
    /*eslint-enable eqeqeq */
    return this.adapter.innerWidth();
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/context-destroy */
  Context.prototype.destroy = function () {
    var allWaypoints = [];
    for (var axis in this.waypoints) {
      for (var waypointKey in this.waypoints[axis]) {
        allWaypoints.push(this.waypoints[axis][waypointKey]);
      }
    }
    for (var i = 0, end = allWaypoints.length; i < end; i++) {
      allWaypoints[i].destroy();
    }
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/context-refresh */
  Context.prototype.refresh = function () {
    /*eslint-disable eqeqeq */
    var isWindow = this.element == this.element.window;
    /*eslint-enable eqeqeq */
    var contextOffset = isWindow ? undefined : this.adapter.offset();
    var triggeredGroups = {};
    var axes;
    this.handleScroll();
    axes = {
      horizontal: {
        contextOffset: isWindow ? 0 : contextOffset.left,
        contextScroll: isWindow ? 0 : this.oldScroll.x,
        contextDimension: this.innerWidth(),
        oldScroll: this.oldScroll.x,
        forward: 'right',
        backward: 'left',
        offsetProp: 'left'
      },
      vertical: {
        contextOffset: isWindow ? 0 : contextOffset.top,
        contextScroll: isWindow ? 0 : this.oldScroll.y,
        contextDimension: this.innerHeight(),
        oldScroll: this.oldScroll.y,
        forward: 'down',
        backward: 'up',
        offsetProp: 'top'
      }
    };
    for (var axisKey in axes) {
      var axis = axes[axisKey];
      for (var waypointKey in this.waypoints[axisKey]) {
        var waypoint = this.waypoints[axisKey][waypointKey];
        var adjustment = waypoint.options.offset;
        var oldTriggerPoint = waypoint.triggerPoint;
        var elementOffset = 0;
        var freshWaypoint = oldTriggerPoint == null;
        var contextModifier, wasBeforeScroll, nowAfterScroll;
        var triggeredBackward, triggeredForward;
        if (waypoint.element !== waypoint.element.window) {
          elementOffset = waypoint.adapter.offset()[axis.offsetProp];
        }
        if (typeof adjustment === 'function') {
          adjustment = adjustment.apply(waypoint);
        } else if (typeof adjustment === 'string') {
          adjustment = parseFloat(adjustment);
          if (waypoint.options.offset.indexOf('%') > -1) {
            adjustment = Math.ceil(axis.contextDimension * adjustment / 100);
          }
        }
        contextModifier = axis.contextScroll - axis.contextOffset;
        waypoint.triggerPoint = Math.floor(elementOffset + contextModifier - adjustment);
        wasBeforeScroll = oldTriggerPoint < axis.oldScroll;
        nowAfterScroll = waypoint.triggerPoint >= axis.oldScroll;
        triggeredBackward = wasBeforeScroll && nowAfterScroll;
        triggeredForward = !wasBeforeScroll && !nowAfterScroll;
        if (!freshWaypoint && triggeredBackward) {
          waypoint.queueTrigger(axis.backward);
          triggeredGroups[waypoint.group.id] = waypoint.group;
        } else if (!freshWaypoint && triggeredForward) {
          waypoint.queueTrigger(axis.forward);
          triggeredGroups[waypoint.group.id] = waypoint.group;
        } else if (freshWaypoint && axis.oldScroll >= waypoint.triggerPoint) {
          waypoint.queueTrigger(axis.forward);
          triggeredGroups[waypoint.group.id] = waypoint.group;
        }
      }
    }
    Waypoint.requestAnimationFrame(function () {
      for (var groupKey in triggeredGroups) {
        triggeredGroups[groupKey].flushTriggers();
      }
    });
    return this;
  };

  /* Private */
  Context.findOrCreateByElement = function (element) {
    return Context.findByElement(element) || new Context(element);
  };

  /* Private */
  Context.refreshAll = function () {
    for (var contextId in contexts) {
      contexts[contextId].refresh();
    }
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/context-find-by-element */
  Context.findByElement = function (element) {
    return contexts[element.waypointContextKey];
  };
  window.onload = function () {
    if (oldWindowLoad) {
      oldWindowLoad();
    }
    Context.refreshAll();
  };
  Waypoint.requestAnimationFrame = function (callback) {
    var requestFn = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || requestAnimationFrameShim;
    requestFn.call(window, callback);
  };
  Waypoint.Context = Context;
})();
(function () {
  'use strict';

  function byTriggerPoint(a, b) {
    return a.triggerPoint - b.triggerPoint;
  }
  function byReverseTriggerPoint(a, b) {
    return b.triggerPoint - a.triggerPoint;
  }
  var groups = {
    vertical: {},
    horizontal: {}
  };
  var Waypoint = window.Waypoint;

  /* http://imakewebthings.com/waypoints/api/group */
  function Group(options) {
    this.name = options.name;
    this.axis = options.axis;
    this.id = this.name + '-' + this.axis;
    this.waypoints = [];
    this.clearTriggerQueues();
    groups[this.axis][this.name] = this;
  }

  /* Private */
  Group.prototype.add = function (waypoint) {
    this.waypoints.push(waypoint);
  };

  /* Private */
  Group.prototype.clearTriggerQueues = function () {
    this.triggerQueues = {
      up: [],
      down: [],
      left: [],
      right: []
    };
  };

  /* Private */
  Group.prototype.flushTriggers = function () {
    for (var direction in this.triggerQueues) {
      var waypoints = this.triggerQueues[direction];
      var reverse = direction === 'up' || direction === 'left';
      waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint);
      for (var i = 0, end = waypoints.length; i < end; i += 1) {
        var waypoint = waypoints[i];
        if (waypoint.options.continuous || i === waypoints.length - 1) {
          waypoint.trigger([direction]);
        }
      }
    }
    this.clearTriggerQueues();
  };

  /* Private */
  Group.prototype.next = function (waypoint) {
    this.waypoints.sort(byTriggerPoint);
    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);
    var isLast = index === this.waypoints.length - 1;
    return isLast ? null : this.waypoints[index + 1];
  };

  /* Private */
  Group.prototype.previous = function (waypoint) {
    this.waypoints.sort(byTriggerPoint);
    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);
    return index ? this.waypoints[index - 1] : null;
  };

  /* Private */
  Group.prototype.queueTrigger = function (waypoint, direction) {
    this.triggerQueues[direction].push(waypoint);
  };

  /* Private */
  Group.prototype.remove = function (waypoint) {
    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);
    if (index > -1) {
      this.waypoints.splice(index, 1);
    }
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/first */
  Group.prototype.first = function () {
    return this.waypoints[0];
  };

  /* Public */
  /* http://imakewebthings.com/waypoints/api/last */
  Group.prototype.last = function () {
    return this.waypoints[this.waypoints.length - 1];
  };

  /* Private */
  Group.findOrCreate = function (options) {
    return groups[options.axis][options.name] || new Group(options);
  };
  Waypoint.Group = Group;
})();
(function () {
  'use strict';

  var Waypoint = window.Waypoint;
  function isWindow(element) {
    return element === element.window;
  }
  function getWindow(element) {
    if (isWindow(element)) {
      return element;
    }
    return element.defaultView;
  }
  function NoFrameworkAdapter(element) {
    this.element = element;
    this.handlers = {};
  }
  NoFrameworkAdapter.prototype.innerHeight = function () {
    var isWin = isWindow(this.element);
    return isWin ? this.element.innerHeight : this.element.clientHeight;
  };
  NoFrameworkAdapter.prototype.innerWidth = function () {
    var isWin = isWindow(this.element);
    return isWin ? this.element.innerWidth : this.element.clientWidth;
  };
  NoFrameworkAdapter.prototype.off = function (event, handler) {
    function removeListeners(element, listeners, handler) {
      for (var i = 0, end = listeners.length - 1; i < end; i++) {
        var listener = listeners[i];
        if (!handler || handler === listener) {
          element.removeEventListener(listener);
        }
      }
    }
    var eventParts = event.split('.');
    var eventType = eventParts[0];
    var namespace = eventParts[1];
    var element = this.element;
    if (namespace && this.handlers[namespace] && eventType) {
      removeListeners(element, this.handlers[namespace][eventType], handler);
      this.handlers[namespace][eventType] = [];
    } else if (eventType) {
      for (var ns in this.handlers) {
        removeListeners(element, this.handlers[ns][eventType] || [], handler);
        this.handlers[ns][eventType] = [];
      }
    } else if (namespace && this.handlers[namespace]) {
      for (var type in this.handlers[namespace]) {
        removeListeners(element, this.handlers[namespace][type], handler);
      }
      this.handlers[namespace] = {};
    }
  };

  /* Adapted from jQuery 1.x offset() */
  NoFrameworkAdapter.prototype.offset = function () {
    if (!this.element.ownerDocument) {
      return null;
    }
    var documentElement = this.element.ownerDocument.documentElement;
    var win = getWindow(this.element.ownerDocument);
    var rect = {
      top: 0,
      left: 0
    };
    if (this.element.getBoundingClientRect) {
      rect = this.element.getBoundingClientRect();
    }
    return {
      top: rect.top + win.pageYOffset - documentElement.clientTop,
      left: rect.left + win.pageXOffset - documentElement.clientLeft
    };
  };
  NoFrameworkAdapter.prototype.on = function (event, handler) {
    var eventParts = event.split('.');
    var eventType = eventParts[0];
    var namespace = eventParts[1] || '__default';
    var nsHandlers = this.handlers[namespace] = this.handlers[namespace] || {};
    var nsTypeList = nsHandlers[eventType] = nsHandlers[eventType] || [];
    nsTypeList.push(handler);
    this.element.addEventListener(eventType, handler);
  };
  NoFrameworkAdapter.prototype.outerHeight = function (includeMargin) {
    var height = this.innerHeight();
    var computedStyle;
    if (includeMargin && !isWindow(this.element)) {
      computedStyle = window.getComputedStyle(this.element);
      height += parseInt(computedStyle.marginTop, 10);
      height += parseInt(computedStyle.marginBottom, 10);
    }
    return height;
  };
  NoFrameworkAdapter.prototype.outerWidth = function (includeMargin) {
    var width = this.innerWidth();
    var computedStyle;
    if (includeMargin && !isWindow(this.element)) {
      computedStyle = window.getComputedStyle(this.element);
      width += parseInt(computedStyle.marginLeft, 10);
      width += parseInt(computedStyle.marginRight, 10);
    }
    return width;
  };
  NoFrameworkAdapter.prototype.scrollLeft = function () {
    var win = getWindow(this.element);
    return win ? win.pageXOffset : this.element.scrollLeft;
  };
  NoFrameworkAdapter.prototype.scrollTop = function () {
    var win = getWindow(this.element);
    return win ? win.pageYOffset : this.element.scrollTop;
  };
  NoFrameworkAdapter.extend = function () {
    var args = Array.prototype.slice.call(arguments);
    function merge(target, obj) {
      if (_typeof(target) === 'object' && _typeof(obj) === 'object') {
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            target[key] = obj[key];
          }
        }
      }
      return target;
    }
    for (var i = 1, end = args.length; i < end; i++) {
      merge(args[0], args[i]);
    }
    return args[0];
  };
  NoFrameworkAdapter.inArray = function (element, array, i) {
    return array == null ? -1 : array.indexOf(element, i);
  };
  NoFrameworkAdapter.isEmptyObject = function (obj) {
    /* eslint no-unused-vars: 0 */
    for (var name in obj) {
      return false;
    }
    return true;
  };
  Waypoint.adapters.push({
    name: 'noframework',
    Adapter: NoFrameworkAdapter
  });
  Waypoint.Adapter = NoFrameworkAdapter;
})();

/***/ }),
/* 3 */
/***/ (function(module, exports) {

/*!
Waypoints Inview Shortcut - 4.0.1
Copyright © 2011-2016 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/
!function () {
  "use strict";

  function t() {}
  function e(t) {
    this.options = i.Adapter.extend({}, e.defaults, t), this.axis = this.options.horizontal ? "horizontal" : "vertical", this.waypoints = [], this.element = this.options.element, this.createWaypoints();
  }
  var i = window.Waypoint;
  e.prototype.createWaypoints = function () {
    for (var t = {
        vertical: [{
          down: "enter",
          up: "exited",
          offset: "100%"
        }, {
          down: "entered",
          up: "exit",
          offset: "bottom-in-view"
        }, {
          down: "exit",
          up: "entered",
          offset: 0
        }, {
          down: "exited",
          up: "enter",
          offset: function offset() {
            return -this.adapter.outerHeight();
          }
        }],
        horizontal: [{
          right: "enter",
          left: "exited",
          offset: "100%"
        }, {
          right: "entered",
          left: "exit",
          offset: "right-in-view"
        }, {
          right: "exit",
          left: "entered",
          offset: 0
        }, {
          right: "exited",
          left: "enter",
          offset: function offset() {
            return -this.adapter.outerWidth();
          }
        }]
      }, e = 0, i = t[this.axis].length; i > e; e++) {
      var n = t[this.axis][e];
      this.createWaypoint(n);
    }
  }, e.prototype.createWaypoint = function (t) {
    var e = this;
    this.waypoints.push(new i({
      context: this.options.context,
      element: this.options.element,
      enabled: this.options.enabled,
      handler: function (t) {
        return function (i) {
          e.options[t[i]].call(e, i);
        };
      }(t),
      offset: t.offset,
      horizontal: this.options.horizontal
    }));
  }, e.prototype.destroy = function () {
    for (var t = 0, e = this.waypoints.length; e > t; t++) {
      this.waypoints[t].destroy();
    }
    this.waypoints = [];
  }, e.prototype.disable = function () {
    for (var t = 0, e = this.waypoints.length; e > t; t++) {
      this.waypoints[t].disable();
    }
  }, e.prototype.enable = function () {
    for (var t = 0, e = this.waypoints.length; e > t; t++) {
      this.waypoints[t].enable();
    }
  }, e.defaults = {
    context: window,
    enabled: !0,
    enter: t,
    entered: t,
    exit: t,
    exited: t
  }, i.Inview = e;
}();

/***/ })
/******/ ]);